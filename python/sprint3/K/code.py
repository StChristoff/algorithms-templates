"""
Гоше дали задание написать красивую сортировку слиянием. Поэтому Гоше обязательно надо реализовать отдельно функцию merge и функцию merge_sort.
Функция merge принимает два отсортированных массива, сливает их в один отсортированный массив и возвращает его.
Если требуемая сигнатура имеет вид merge(array, left, mid, right), то первый массив задаётся полуинтервалом 
[left,mid) массива array, а второй – полуинтервалом [mid,right) массива array.
Функция merge_sort принимает некоторый подмассив, который нужно отсортировать. Подмассив задаётся полуинтервалом — его началом и концом. 
Функция должна отсортировать передаваемый в неё подмассив, она ничего не возвращает.
Функция merge_sort разбивает полуинтервал на две половинки и рекурсивно вызывает сортировку отдельно для каждой. 
Затем два отсортированных массива сливаются в один с помощью merge.
Заметьте, что в функции передаются именно полуинтервалы [begin,end), то есть правый конец не включается. Например, если вызвать merge_sort(arr, 0, 4),
где arr=[4,5,3,0,1,2], то будут отсортированы только первые четыре элемента, изменённый массив будет выглядеть как arr=[0,3,4,5,1,2].
Реализуйте эти две функции.

Формат ввода
Передаваемый в функции массив состоит из целых чисел, не превосходящих по модулю 10^9. Длина сортируемого диапазона не превосходит 10^5.

Формат вывода
Решение нужно отправлять в виде файла с расширением соответствующем вашему языку программирования.
Для остальных языков программирования это имя использовать нельзя (имя «solution» тоже).
"""


def merge(arr, lf, mid, rg):
	if len(arr) == 1:  # базовый случай рекурсии
		return arr
	# запускаем сортировку рекурсивно на левой половине
	left = merge(arr[lf : mid], lf, mid // 2, mid)

	# запускаем сортировку рекурсивно на правой половине
	right = merge(arr[mid : rg], lf, (rg - mid) // 2, rg - mid)

	# заводим массив для результата сортировки
	result = [] * rg
  
	# сливаем результаты
	l, r, k = 0, 0, 0
	while l < mid and r < (rg - mid):
		# выбираем, из какого массива забрать минимальный элемент
		if left[l] <= right[r]:
			result[k] = left[l]
			l += 1
		else:
			result[k] = right[r]
			r += 1
		k += 1

	# Если один массив закончился раньше, чем второй, то
	# переносим оставшиеся элементы второго массива в результирующий
	while l < mid:
		result[k] = left[l] # перенеси оставшиеся элементы left в result
		l += 1
		k += 1
	while r < (rg - mid):
		result[k] = right[r] # перенеси оставшиеся элементы right в result
		r += 1
		k += 1
	return result


def merge_sort(arr, lf, rg):
	# Your code
	# “ヽ(´▽｀)ノ”
	pass

def test():
	a = [1, 4, 9, 2, 10, 11]
	b = merge(a, 0, 3, 6)
	expected = [1, 2, 4, 9, 10, 11]
	assert b == expected
	# c = [1, 4, 2, 10, 1, 2]
	# merge_sort(c, 0 , 6)
	# expected = [1, 1, 2, 2, 4, 10]
	# assert c == expected

if __name__ == '__main__':
    test()